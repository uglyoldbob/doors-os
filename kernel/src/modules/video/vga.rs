//! Kernel module for x86 vga text using video mode

use crate::modules::video::TextDisplayTrait;

use crate::boot::x86::IoPortArray;
use crate::boot::x86::IoPortRef;
use crate::boot::x86::IoReadWrite;
use crate::boot::x86::IOPORTS;

/// The memory portion of the x86 hardware
pub struct X86VgaHardware {
    /// The actual memory
    buf: [u8; 0x20000],
}

/// The structure for vga hardware. This driver assumes color mode only.
pub struct X86VgaMode {
    /// The column where the next character will be placed
    column: u8,
    /// The row where the next character will be placed
    row: u8,
    /// A mutable reference to the hardware memory
    hw: &'static mut X86VgaHardware,
    /// The io ports for the vga hardware
    ports: IoPortArray<'static>,
}

/// The default palette for vga operations
pub const DEFAULT_PALETTE: &[u8] = &[
    0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x2a, 0x00, 0x00, 0x2a, 0x2a, 0x2a, 0x00, 0x00, 0x2a,
    0x00, 0x2a, 0x2a, 0x15, 0x00, 0x2a, 0x2a, 0x2a, 0x15, 0x15, 0x15, 0x15, 0x15, 0x3f, 0x15, 0x3f,
    0x15, 0x15, 0x3f, 0x3f, 0x3f, 0x15, 0x15, 0x3f, 0x15, 0x3f, 0x3f, 0x3f, 0x15, 0x3f, 0x3f, 0x3f,
    0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x08, 0x08, 0x08, 0x0b, 0x0b, 0x0b, 0x0e, 0x0e, 0x0e, 0x11,
    0x11, 0x11, 0x14, 0x14, 0x14, 0x18, 0x18, 0x18, 0x1c, 0x1c, 0x1c, 0x20, 0x20, 0x20, 0x24, 0x24,
    0x24, 0x28, 0x28, 0x28, 0x2d, 0x2d, 0x2d, 0x32, 0x32, 0x32, 0x38, 0x38, 0x38, 0x3f, 0x3f, 0x3f,
    0x00, 0x00, 0x3f, 0x10, 0x00, 0x3f, 0x1f, 0x00, 0x3f, 0x2f, 0x00, 0x3f, 0x3f, 0x00, 0x3f, 0x3f,
    0x00, 0x2f, 0x3f, 0x00, 0x1f, 0x3f, 0x00, 0x10, 0x3f, 0x00, 0x00, 0x3f, 0x10, 0x00, 0x3f, 0x1f,
    0x00, 0x3f, 0x2f, 0x00, 0x3f, 0x3f, 0x00, 0x2f, 0x3f, 0x00, 0x1f, 0x3f, 0x00, 0x10, 0x3f, 0x00,
    0x00, 0x3f, 0x00, 0x00, 0x3f, 0x10, 0x00, 0x3f, 0x1f, 0x00, 0x3f, 0x2f, 0x00, 0x3f, 0x3f, 0x00,
    0x2f, 0x3f, 0x00, 0x1f, 0x3f, 0x00, 0x10, 0x3f, 0x1f, 0x1f, 0x3f, 0x27, 0x1f, 0x3f, 0x2f, 0x1f,
    0x3f, 0x37, 0x1f, 0x3f, 0x3f, 0x1f, 0x3f, 0x3f, 0x1f, 0x37, 0x3f, 0x1f, 0x2f, 0x3f, 0x1f, 0x27,
    0x3f, 0x1f, 0x1f, 0x3f, 0x27, 0x1f, 0x3f, 0x2f, 0x1f, 0x3f, 0x37, 0x1f, 0x3f, 0x3f, 0x1f, 0x37,
    0x3f, 0x1f, 0x2f, 0x3f, 0x1f, 0x27, 0x3f, 0x1f, 0x1f, 0x3f, 0x1f, 0x1f, 0x3f, 0x27, 0x1f, 0x3f,
    0x2f, 0x1f, 0x3f, 0x37, 0x1f, 0x3f, 0x3f, 0x1f, 0x37, 0x3f, 0x1f, 0x2f, 0x3f, 0x1f, 0x27, 0x3f,
    0x2d, 0x2d, 0x3f, 0x31, 0x2d, 0x3f, 0x36, 0x2d, 0x3f, 0x3a, 0x2d, 0x3f, 0x3f, 0x2d, 0x3f, 0x3f,
    0x2d, 0x3a, 0x3f, 0x2d, 0x36, 0x3f, 0x2d, 0x31, 0x3f, 0x2d, 0x2d, 0x3f, 0x31, 0x2d, 0x3f, 0x36,
    0x2d, 0x3f, 0x3a, 0x2d, 0x3f, 0x3f, 0x2d, 0x3a, 0x3f, 0x2d, 0x36, 0x3f, 0x2d, 0x31, 0x3f, 0x2d,
    0x2d, 0x3f, 0x2d, 0x2d, 0x3f, 0x31, 0x2d, 0x3f, 0x36, 0x2d, 0x3f, 0x3a, 0x2d, 0x3f, 0x3f, 0x2d,
    0x3a, 0x3f, 0x2d, 0x36, 0x3f, 0x2d, 0x31, 0x3f, 0x00, 0x00, 0x1c, 0x07, 0x00, 0x1c, 0x0e, 0x00,
    0x1c, 0x15, 0x00, 0x1c, 0x1c, 0x00, 0x1c, 0x1c, 0x00, 0x15, 0x1c, 0x00, 0x0e, 0x1c, 0x00, 0x07,
    0x1c, 0x00, 0x00, 0x1c, 0x07, 0x00, 0x1c, 0x0e, 0x00, 0x1c, 0x15, 0x00, 0x1c, 0x1c, 0x00, 0x15,
    0x1c, 0x00, 0x0e, 0x1c, 0x00, 0x07, 0x1c, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x1c, 0x07, 0x00, 0x1c,
    0x0e, 0x00, 0x1c, 0x15, 0x00, 0x1c, 0x1c, 0x00, 0x15, 0x1c, 0x00, 0x0e, 0x1c, 0x00, 0x07, 0x1c,
    0x0e, 0x0e, 0x1c, 0x11, 0x0e, 0x1c, 0x15, 0x0e, 0x1c, 0x18, 0x0e, 0x1c, 0x1c, 0x0e, 0x1c, 0x1c,
    0x0e, 0x18, 0x1c, 0x0e, 0x15, 0x1c, 0x0e, 0x11, 0x1c, 0x0e, 0x0e, 0x1c, 0x11, 0x0e, 0x1c, 0x15,
    0x0e, 0x1c, 0x18, 0x0e, 0x1c, 0x1c, 0x0e, 0x18, 0x1c, 0x0e, 0x15, 0x1c, 0x0e, 0x11, 0x1c, 0x0e,
    0x0e, 0x1c, 0x0e, 0x0e, 0x1c, 0x11, 0x0e, 0x1c, 0x15, 0x0e, 0x1c, 0x18, 0x0e, 0x1c, 0x1c, 0x0e,
    0x18, 0x1c, 0x0e, 0x15, 0x1c, 0x0e, 0x11, 0x1c, 0x14, 0x14, 0x1c, 0x16, 0x14, 0x1c, 0x18, 0x14,
    0x1c, 0x1a, 0x14, 0x1c, 0x1c, 0x14, 0x1c, 0x1c, 0x14, 0x1a, 0x1c, 0x14, 0x18, 0x1c, 0x14, 0x16,
    0x1c, 0x14, 0x14, 0x1c, 0x16, 0x14, 0x1c, 0x18, 0x14, 0x1c, 0x1a, 0x14, 0x1c, 0x1c, 0x14, 0x1a,
    0x1c, 0x14, 0x18, 0x1c, 0x14, 0x16, 0x1c, 0x14, 0x14, 0x1c, 0x14, 0x14, 0x1c, 0x16, 0x14, 0x1c,
    0x18, 0x14, 0x1c, 0x1a, 0x14, 0x1c, 0x1c, 0x14, 0x1a, 0x1c, 0x14, 0x18, 0x1c, 0x14, 0x16, 0x1c,
    0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08, 0x00, 0x10, 0x0c, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10,
    0x00, 0x0c, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08,
    0x00, 0x10, 0x0c, 0x00, 0x10, 0x10, 0x00, 0x0c, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08, 0x00, 0x10, 0x0c, 0x00, 0x10, 0x10, 0x00,
    0x0c, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x08, 0x08, 0x10, 0x0a, 0x08, 0x10, 0x0c, 0x08,
    0x10, 0x0e, 0x08, 0x10, 0x10, 0x08, 0x10, 0x10, 0x08, 0x0e, 0x10, 0x08, 0x0c, 0x10, 0x08, 0x0a,
    0x10, 0x08, 0x08, 0x10, 0x0a, 0x08, 0x10, 0x0c, 0x08, 0x10, 0x0e, 0x08, 0x10, 0x10, 0x08, 0x0e,
    0x10, 0x08, 0x0c, 0x10, 0x08, 0x0a, 0x10, 0x08, 0x08, 0x10, 0x08, 0x08, 0x10, 0x0a, 0x08, 0x10,
    0x0c, 0x08, 0x10, 0x0e, 0x08, 0x10, 0x10, 0x08, 0x0e, 0x10, 0x08, 0x0c, 0x10, 0x08, 0x0a, 0x10,
    0x0b, 0x0b, 0x10, 0x0c, 0x0b, 0x10, 0x0d, 0x0b, 0x10, 0x0f, 0x0b, 0x10, 0x10, 0x0b, 0x10, 0x10,
    0x0b, 0x0f, 0x10, 0x0b, 0x0d, 0x10, 0x0b, 0x0c, 0x10, 0x0b, 0x0b, 0x10, 0x0c, 0x0b, 0x10, 0x0d,
    0x0b, 0x10, 0x0f, 0x0b, 0x10, 0x10, 0x0b, 0x0f, 0x10, 0x0b, 0x0d, 0x10, 0x0b, 0x0c, 0x10, 0x0b,
    0x0b, 0x10, 0x0b, 0x0b, 0x10, 0x0c, 0x0b, 0x10, 0x0d, 0x0b, 0x10, 0x0f, 0x0b, 0x10, 0x10, 0x0b,
    0x0f, 0x10, 0x0b, 0x0d, 0x10, 0x0b, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

impl X86VgaMode {
    /// Gets an instance of the X86Vga. This should be protected by a singleton type pattern to prevent multiple instances from being handed out to the kernel.
    pub unsafe fn get(adr: usize) -> Option<Self> {
        let ports = IOPORTS.get_ports(0x3c0, 32).unwrap();
        let mut check = Self {
            hw: &mut *(adr as *mut X86VgaHardware),
            column: 0,
            row: 0,
            ports,
        };
        let emulation_mode = check.read_misc_output_register() & 1;
        check.write_misc_output_register(0x63);
        check.write_sequencer_register(0, 3);
        check.write_sequencer_register(1, 1);
        check.write_sequencer_register(2, 0xf);
        check.write_sequencer_register(3, 0);
        check.write_sequencer_register(4, 6);
        check.unlock_crtc_registers(emulation_mode);
        for (i, val) in [
            0x5f, 0x4f, 0x50, 0x82, 0x54, 0x80, 0x0d, 0x3e, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xea, 0xac, 0xdf, 0x28, 0x00, 0xe7, 0x06, 0xe3, 0xff,
        ]
        .iter()
        .enumerate()
        {
            check.write_crt_controller_register(i as u8, *val);
        }

        for (i, val) in [0, 0, 0, 0, 0, 0x40, 0x05, 0x0f, 0xff].iter().enumerate() {
            check.write_graphics_register(i as u8, *val);
        }

        check.blank_screen();

        for (i, val) in [
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x41, 0, 0x0f, 0x00,
            0x00,
        ]
        .iter()
        .enumerate()
        {
            check.write_attribute_color_register(i as u8, *val);
        }

        check.write_palette(DEFAULT_PALETTE);

        check.set_plane_mask(0xF);
        for i in check.hw.buf.iter_mut() {
            *i = 0x32;
        }

        check.unblank_screen();

        check.set_plane_mask(0x1);
        for i in check.hw.buf.iter_mut().skip(960).take(1) {
            *i = 0x01;
        }

        Some(check)
    }

    fn read_misc_output_register(&self) -> u8 {
        self.ports.port(0xc).port_read()
    }

    fn write_misc_output_register(&self, v: u8) {
        self.ports.port(0x2).port_write(v);
    }

    fn read_feature_control_register(&self) -> u8 {
        self.ports.port(0xA).port_read()
    }

    fn write_feature_control_register(&mut self, v: u8) {
        self.ports.port(0x1a).port_write(v);
    }

    fn read_status0_register(&self) -> u8 {
        self.ports.port(2).port_read()
    }

    fn read_status1_register(&self) -> u8 {
        self.ports.port(0x1a).port_read()
    }

    fn read_graphics_register(&mut self, i: u8) -> u8 {
        self.ports.port(0xe).port_write(i);
        self.ports.port(0xf).port_read()
    }

    fn write_graphics_register(&mut self, i: u8, val: u8) {
        self.ports.port(0xe).port_write(i);
        self.ports.port(0xf).port_write(val);
    }

    fn read_sequencer_register(&mut self, i: u8) -> u8 {
        self.ports.port(0x4).port_write(i);
        self.ports.port(0x5).port_read()
    }

    fn write_sequencer_register(&mut self, i: u8, val: u8) {
        self.ports.port(0x4).port_write(i);
        self.ports.port(0x5).port_write(val);
    }

    fn set_plane_mask(&mut self, mask: u8) {
        let val: u8 = self.read_sequencer_register(2) & 0xF0;
        self.write_sequencer_register(2, val | (mask & 0xF));
    }

    fn read_attribute_color_register(&mut self, i: u8) -> u8 {
        let _: u8 = self.ports.port(0x1a).port_read();
        self.ports.port(0x0).port_write(i);
        self.ports.port(0x1).port_read()
    }

    fn write_attribute_color_register(&mut self, i: u8, val: u8) {
        let _: u8 = self.ports.port(0x1a).port_read();
        self.ports.port(0x0).port_write(i);
        self.ports.port(0x0).port_write(val);
    }

    fn read_crt_controller_register(&mut self, i: u8) -> u8 {
        self.ports.port(0x14).port_write(i);
        self.ports.port(0x15).port_read()
    }

    fn write_crt_controller_register(&mut self, i: u8, val: u8) {
        self.ports.port(0x14).port_write(i);
        self.ports.port(0x15).port_write(val);
    }

    fn blank_screen(&mut self) {
        let _: u8 = self.ports.port(0x1a).port_read();
        let v: u8 = self.ports.port(0).port_read();
        self.ports.port(0).port_write(v & 0xdf);
    }

    fn unblank_screen(&mut self) {
        let _: u8 = self.ports.port(0x1a).port_read();
        let v: u8 = self.ports.port(0).port_read();
        self.ports.port(0).port_write(v | 0x20);
    }

    fn unlock_crtc_registers(&mut self, _mode: u8) {
        let hblank_end = self.read_crt_controller_register(3);
        self.write_crt_controller_register(3, hblank_end | 0x80);

        let vblank_end = self.read_crt_controller_register(11);
        self.write_crt_controller_register(11, vblank_end & 0x7f);
    }

    fn write_palette(&mut self, p: &[u8]) {
        self.ports.port(8).port_write(0 as u8);
        for val in p {
            self.ports.port(9).port_write(*val);
        }
    }

    fn read_palette(&mut self, p: &mut [u8]) {
        self.ports.port(8).port_write(0 as u8);
        for val in p.iter_mut() {
            *val = self.ports.port(9).port_read();
        }
    }
}

impl super::TextDisplayTrait for X86VgaMode {
    fn print_char(&mut self, d: char) {}
}
