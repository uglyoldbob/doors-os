Ideas and thoughts for virtual memory management

data required in order for the system to work properly
virtual address
list of available physical addresses



//remove from ram
	//place onto disk storage
-virtual address will be given
-find some room on disk (there should be dedicated paging areas on disk), if there is none, return an error
	-there should only be one virtual memory area per disk/drive (not per partition)
	-later on, there should be an option to increase the total size of diskRam
-move memory from ram to disk
-declare the page as not present
-return the physical address removed from ram (the virtual address is given)

//place into ram
	//remove from disk storage
-virtual address (given)
-make sure that the virtual address is actually a valid address
	*if it is invalid, return an error
-find or make some room (in ram)
-attempt to allocate a page (this won't work too well if the allocator freezes until memory is available)
-move memory from ram to disk if the page allocation fails
	*use the memory that is freed by that operation
-take the memory that was just obtained (if memory was actually obtained)
	-move memory from disk to ram
-point the page table entry to the address just used and mark it as present
-do the usual page table entry modification stuff
-return the physical address used (virtual address is given)

functions required
-make space available in RAM
	*depends on being able to swap memory out to disk already
-locate free space in paged memory (memory that is located on disks/drives)

**FUNCTIONS COMPLETED**
-move memory from paged memory to ram
	*this is already done, might need slight modifications
-move memory from ram to paged memory
	*this is already done, might need slight modifications
-locate unused space in RAM (new)
-fill out page table entry and invalidate TLB for the virtual memory address in question
	*mark as present and fill in the physical address
-fill out page table entry and invalidate the TLB for the virtual memory address in question
	*mark as non-present and fill in the appropriate lot number 
		-(which allows location of the page among all other pages in paged memory)


page fault flag
-page table entry or page directory entry has the present flag clear
-invalid privelages to access the page
-user mode code attempts to write to a read only page
-reserved bits in the page directory entry are set to 1
p flag 	(not present, 0)
		(access rights violation or use of a reserved bit, 1)
w/r flag indicates if the problem was caused by a read or write
u/s indicates whether it was user or supervisor mode at the time
rsvd flag is to indicate that reserved flags were set, not sure it this applies for the 386
//error code format for the page fualt exception
XXXX XXXX XXXX XXXX XXXX XXXX XXXX (RSVD)(U/S)(R/W)(P)
also the cr2 register is used for the page fault exception
the cr2 register is loaded with the 32-bit virtual address

