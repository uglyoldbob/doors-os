Thoughts on things to do.

TODO: work on the device driver / module models for the os
//need to work on a model for modules first
//copy on write
//pic for modules?

File access
	After thinking for a while on how various devices should be accessed, the unix concept of "everything is a file" started to make a whole lot of sense. These various devices I had in mind included the serial port and ports on network cards (still unsupported).

Linux way for device drivers
	user space and kernel space functions (not new)
	load, open, read, write, close, unload
	block drivers and character drivers (refers to the amount of data accesses at the same time)
	kernel code, standard interface, uses kernel services, un/load on demand, 	

open:
	//fopen(device name, mode)
	//need to parse the device name to figure out where to send the open request to
	
//calls are passed to proper driver (the device special file; /dev/video) via the major device number and a system table
	//the system table used depends oon what kind of device is being referred to (char, block, network, alien, whatever)

	//get a list of all file operations and enumerate them
	//



//pointer to the name of the driver, and a pointer to the block of file operations
//the device special files are represented by vfs inodes

//item x depends on y
file access -> filesystem driver
filesystem driver -> disk/storage driver
disk/storage driver -> hardware

//network devices use the bsd socket interface

//interrupt hooking for device drivers (I think I already have it implemented, but need to step it up and add a few features to it)
//dma handling needs polishing and more features (i think it has been a while since i have looked at it)
	//need a way of obtaining DMA memory
		//if all dma memory is full, relocate some dma to non-dma locations through the virtual memory
//need a way to allocate from the non-paged memory
//most device drivers use non-paged memory
//TODO: create a list of major identifiers
//all devices controlled by the same device driver have the same major identifier
	//primary ide - 3
	//tty device - 4
	//scsi - 8
	//secondary ide - 22


dma: pointer to owner, and an allocation flag


Register device names as they are detected. Mapping from name (special device file) to hardware is done by using a major device number and some system tables. Drivers check for hardware that they work with and go from there.

The syntax for file access will be similar to Linux/*nix/whatever
Starts with a '/'
It would not be too hard to implement "windows style" drive naming convention in parallel with the "normal" method of file addressing.

Then the "drive" name
After the drive name will come the partition number
FORM: /device/partition number/folder/folder/file
EX: /floppy1/1, /floppy2/1, /hd1/1, /hd1/2, /cd1/1, /cd2/1
A floppy disk is assumed to not have partitions, but still a partition specifier is required
The first partition is partition 1, not partition 0

Disk access. Everything is in the path name to find the partition required. Both drive number and partition number are given. The text string will need to be run through an interpreter (which might eventually be unicode aware). Once the bootsector for the partition has been located, it will be sent to each file system driver until a match is found.
EX: access for /hd1/2/loser.txt is needed.
	Access hd1. Locate Partition 2.
	Load bootsector for partition 2. The MBR should tell us what kind of filesystem is there. If for some reason, using that driver returns an error, every file system driver will be queried. If no drivers return a success code, then the partition is not usable for some reason. That should generate an error code.
		The FAT driver should/will return an error when reading an NTFS.

findPartition(floppy1/1)
readFile(/floppy1/1/file.txt)
	
class disk
	subclass floppy
	subclass hard drive (ide)
	subclass cd (ide)
	subclass flash drive
	subclass whatever
class filesystem
	subclass fat
	subclass ntfs
	subclass extfs
	subclass whatever
class file
	class **disk
	class **filesystem
	

Certain information will need to be stored for each drive accessible by this method.
	Drive name (floppya, floppyb, ...)
	Hardware device that data comes from (hardware devices can be emulated to provide support for image files)
	the sector number for the bootsector (contains information about the filesystem)
	
Hardware devices access
	sector_number ranges from 0-whatever
	buffer
	read,write sector
	the appropriate locks so that only one process or thread attempts to access a device at one time
	
SYSTEMWIDE PORT PROTECTION:
The current theoretical system needs a way to ensure that more than one driver does not try to access the same hardware devices at the same time. This will probably require that some form of port protection be coded. Right now you could load two different drivers that access the same hardware device.
	
